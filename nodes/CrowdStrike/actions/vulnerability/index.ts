/*
 * Copyright (c) Velocity BPA, LLC
 * Licensed under the Business Source License 1.1
 * Commercial use requires a separate commercial license.
 * See LICENSE file for details.
 */

import type { IExecuteFunctions, IDataObject } from 'n8n-workflow';
import {
	crowdStrikeApiRequest,
	crowdStrikeGetAllItems,
} from '../../transport';

export async function getAll(this: IExecuteFunctions, i: number): Promise<IDataObject[]> {
	const returnAll = this.getNodeParameter('returnAll', i) as boolean;
	const filters = this.getNodeParameter('filters', i, {}) as IDataObject;
	const limit = this.getNodeParameter('limit', i, 100) as number;

	const filterParts: string[] = [];

	if (filters.severity) {
		filterParts.push(`cve.severity:'${filters.severity}'`);
	}
	if (filters.status) {
		filterParts.push(`status:'${filters.status}'`);
	}
	if (filters.cveId) {
		filterParts.push(`cve.id:'${filters.cveId}'`);
	}
	if (filters.productName) {
		filterParts.push(`apps.product_name_version:'*${filters.productName}*'`);
	}
	if (filters.hostId) {
		filterParts.push(`host_info.aid:'${filters.hostId}'`);
	}
	if (filters.hostname) {
		filterParts.push(`host_info.hostname:'*${filters.hostname}*'`);
	}
	if (filters.suppressed !== undefined) {
		filterParts.push(`suppression_info.is_suppressed:${filters.suppressed}`);
	}
	if (filters.exploitStatus) {
		filterParts.push(`cve.exploit_status:'${filters.exploitStatus}'`);
	}
	if (filters.createdAfter) {
		filterParts.push(`created_timestamp:>='${filters.createdAfter}'`);
	}
	if (filters.createdBefore) {
		filterParts.push(`created_timestamp:<='${filters.createdBefore}'`);
	}
	if (filters.minBaseScore) {
		filterParts.push(`cve.base_score:>=${filters.minBaseScore}`);
	}
	if (filters.maxBaseScore) {
		filterParts.push(`cve.base_score:<=${filters.maxBaseScore}`);
	}

	const qs: IDataObject = {};
	if (filterParts.length > 0) {
		qs.filter = filterParts.join('+');
	}

	if (returnAll) {
		return crowdStrikeGetAllItems.call(
			this,
			'/spotlight/queries/vulnerabilities/v1',
			'/spotlight/entities/vulnerabilities/v2',
			qs,
		);
	}

	qs.limit = limit;
	const queryResponse = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/queries/vulnerabilities/v1',
		undefined,
		qs,
	);

	if (!queryResponse.resources || queryResponse.resources.length === 0) {
		return [];
	}

	const detailsResponse = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/entities/vulnerabilities/v2',
		undefined,
		{ ids: queryResponse.resources },
	);

	return detailsResponse.resources || [];
}

export async function get(this: IExecuteFunctions, i: number): Promise<IDataObject> {
	const vulnerabilityId = this.getNodeParameter('vulnerabilityId', i) as string;

	const response = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/entities/vulnerabilities/v2',
		undefined,
		{ ids: vulnerabilityId },
	);

	if (!response.resources || response.resources.length === 0) {
		throw new Error(`Vulnerability with ID "${vulnerabilityId}" not found`);
	}

	return response.resources[0];
}

export async function getByHost(this: IExecuteFunctions, i: number): Promise<IDataObject[]> {
	const hostId = this.getNodeParameter('hostId', i) as string;
	const returnAll = this.getNodeParameter('returnAll', i) as boolean;
	const filters = this.getNodeParameter('filters', i, {}) as IDataObject;
	const limit = this.getNodeParameter('limit', i, 100) as number;

	const filterParts: string[] = [`host_info.aid:'${hostId}'`];

	if (filters.severity) {
		filterParts.push(`cve.severity:'${filters.severity}'`);
	}
	if (filters.status) {
		filterParts.push(`status:'${filters.status}'`);
	}
	if (filters.suppressed !== undefined) {
		filterParts.push(`suppression_info.is_suppressed:${filters.suppressed}`);
	}

	const qs: IDataObject = { filter: filterParts.join('+') };

	if (returnAll) {
		return crowdStrikeGetAllItems.call(
			this,
			'/spotlight/queries/vulnerabilities/v1',
			'/spotlight/entities/vulnerabilities/v2',
			qs,
		);
	}

	qs.limit = limit;
	const queryResponse = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/queries/vulnerabilities/v1',
		undefined,
		qs,
	);

	if (!queryResponse.resources || queryResponse.resources.length === 0) {
		return [];
	}

	const detailsResponse = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/entities/vulnerabilities/v2',
		undefined,
		{ ids: queryResponse.resources },
	);

	return detailsResponse.resources || [];
}

export async function getByCve(this: IExecuteFunctions, i: number): Promise<IDataObject[]> {
	const cveId = this.getNodeParameter('cveId', i) as string;
	const returnAll = this.getNodeParameter('returnAll', i) as boolean;
	const filters = this.getNodeParameter('filters', i, {}) as IDataObject;
	const limit = this.getNodeParameter('limit', i, 100) as number;

	const filterParts: string[] = [`cve.id:'${cveId}'`];

	if (filters.severity) {
		filterParts.push(`cve.severity:'${filters.severity}'`);
	}
	if (filters.status) {
		filterParts.push(`status:'${filters.status}'`);
	}
	if (filters.hostname) {
		filterParts.push(`host_info.hostname:'*${filters.hostname}*'`);
	}
	if (filters.suppressed !== undefined) {
		filterParts.push(`suppression_info.is_suppressed:${filters.suppressed}`);
	}

	const qs: IDataObject = { filter: filterParts.join('+') };

	if (returnAll) {
		return crowdStrikeGetAllItems.call(
			this,
			'/spotlight/queries/vulnerabilities/v1',
			'/spotlight/entities/vulnerabilities/v2',
			qs,
		);
	}

	qs.limit = limit;
	const queryResponse = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/queries/vulnerabilities/v1',
		undefined,
		qs,
	);

	if (!queryResponse.resources || queryResponse.resources.length === 0) {
		return [];
	}

	const detailsResponse = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/entities/vulnerabilities/v2',
		undefined,
		{ ids: queryResponse.resources },
	);

	return detailsResponse.resources || [];
}

export async function getRemediations(this: IExecuteFunctions, i: number): Promise<IDataObject[]> {
	const cveIds = this.getNodeParameter('cveIds', i) as string;
	const ids = cveIds.split(',').map((id) => id.trim());

	const response = await crowdStrikeApiRequest.call(
		this,
		'GET',
		'/spotlight/entities/remediations/v2',
		undefined,
		{ ids },
	);

	return response.resources || [];
}
